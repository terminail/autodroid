# DeepSeek 跨平台安卓应用自动化容器解决方案

## Q: 好把上面从“根据上面讨论，我准备采用容器方式自动化操纵第三方apk方式，这个容器可以是podman、docker根据用户选择，支持Macos、WSL/Linux、Windows部署，请给我编写一个完整需求？”开始讨论的内容整理成一个完整的文档，内容包括需求文档、技术方案、工具安装apk分析等。以便指导开发人员分部实施。[DeepSeek:跨平台安卓应用自动化容器解决方案](https://chat.deepseek.com/a/chat/s/519ce808-5602-45c6-bebb-96e2eb47add8)

## A: 好的，我会根据上面的讨论整理出一个完整的文档，包括需求文档、技术方案、工具安装、apk分析等。请稍后。

## 项目概述

### 1.1 项目背景
随着移动应用测试需求的增长，需要一套能够跨平台部署、支持多设备并发、易于管理的自动化测试解决方案。传统方案存在环境配置复杂、平台兼容性差、维护成本高等问题。

### 1.2 解决方案
开发基于容器技术的跨平台安卓应用自动化框架，通过Appium实现标准UI自动化，结合工作计划系统，提供稳定可靠的第三方APK自动化测试能力。

### 1.3 核心价值
- 🐳 **容器化部署**：支持Docker和Podman，消除环境依赖
- 🖥️ **全平台支持**：macOS、Windows、WSL/Linux
- 📱 **非侵入式**：无需修改目标APK，基于UI层次分析
- 🔧 **工作计划**：支持计划任务和事件驱动测试
- 📊 **集中管理**：统一的配置管理和结果监控

---

## 一、需求文档

### 1. 功能需求

#### 1.1 核心功能模块

**F001 - 容器化部署管理**
- 支持Docker和Podman容器运行时
- 自动检测和适配宿主平台
- 一键启动和停止服务
- 容器健康状态监控

**F002 - 设备注册**
- 网络ADB设备注册和连接
- USB设备直连支持（Linux/macOS）
- 设备状态实时监控（电量、存储、网络）
- 多设备并行管理（最多5台并发）

**F003 - APK智能分析**
- 自动扫描手机已安装APK
- 提取包名、应用名称、版本信息
- 识别主Activity和界面结构
- 生成基础工作流模板

**F004 - 工作脚本引擎**
- YAML配置驱动的工作脚本定义
- 支持数据驱动的测试用例
- 条件分支和循环控制
- 步骤级超时和重试机制

**F005 - 工作计划系统**
- 基于时间的计划任务
- 事件驱动的自动触发
- 资源感知的工作计划
- 任务队列和优先级管理

**F006 - 工作报告系统**
- 实时执行日志记录
- 自动化报告生成（HTML/JSON）
- 失败截图自动保存
- 性能指标统计和分析

### 2. 非功能需求

#### 2.1 性能要求
- 容器启动时间 < 30秒
- 元素定位响应时间 < 3秒
- 支持并发执行5个自动化任务
- 内存占用 < 1GB

#### 2.2 可靠性要求
- 自动化任务成功率 > 98%
- 网络中断自动恢复
- 设备断连重连机制
- 完整的异常处理

#### 2.3 兼容性要求
- Android 8.0+ 设备支持
- 支持x86_64和ARM64架构
- 适配多种屏幕分辨率
- 支持亮色/暗色主题

---

## 二、系统架构

### 1. 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                   容器服务器 (Container Server)              │
├─────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐   │
│  │  工作脚本引擎 │  │  工作计划系统 │  │  APK管理      │  │   设备管理       │   │
│  │              │  │              │  │              │  │                  │   │
│  └───────┬──────┘  └───────┬──────┘  └───────┬────┘  └──────────┬───────┘   │
│          │                 │                    │           │
│  ┌─────────────────┬─────────────────┐   │
│  │ WebSocket/HTTP/RESTful API 服务 │  │ 消息通信层 ADB/Wifi/USB │   │
│  └────────┬────────┴────────┬────────┘   │
└───────────┼─────────────────┼──────────────┘
            │                 │
            └───────┬─────────┘
                   │
                               │
       ┌───────────────────────┼───────────────────────┐
       │                       │                       │
┌──────┴──────┐         ┌──────┴──────┐         ┌──────┴──────┐
│  测试机A    │         │  测试机B    │         │  测试机C    │
│  ┌────────┐ │         │  ┌────────┐ │         │  ┌────────┐ │
│  │代理APP │ │         │  │代理APP │ │         │  │代理APP │ │
│  └────────┘ │         │  └────────┘ │         │  └────────┘ │
└─────────────┘         └─────────────┘         └─────────────┘
```

### 2. 容器服务架构

```yaml
# docker-compose.yml
version: '3.8'

services:
  appium-server:
    image: appium/appium:latest
    ports: ["4723:4723"]
    privileged: true
    environment:
      - RELAXED_SECURITY=true
      - ALLOW_INSECURE=adb_shell

  automation-core:
    image: autodroid/core:latest
    depends_on: [appium-server]
    environment:
      - APPIUM_URL=http://appium-server:4723
      - MAX_CONCURRENT_TASKS=5
    volumes:
      - ./workflows:/app/workflows
      - ./reports:/app/reports

  device-manager:
    image: autodroid/device-manager:latest
    privileged: true
    devices:
      - /dev/bus/usb:/dev/bus/usb
    volumes:
      - /var/run/usbmuxd:/var/run/usbmuxd
```

---

## 三、技术方案

### 1. 技术栈选择

#### 核心框架
- **自动化引擎**: Appium + UI Automator 2
- **设备通信**: ADB + Appium Server
- **容器运行时**: Docker + Podman
- **编程语言**: Python 3.11+

#### 辅助工具
- **APK分析**: aapt, apktool, jadx
- **UI分析**: Appium Inspector, UI Automator Viewer
- **报告生成**: Allure, pytest-html
- **配置管理**: Pydantic, YAML

#### 开发工具
- **API框架**: FastAPI
- **测试框架**: pytest
- **代码质量**: flake8, black, mypy
- **CI/CD**: GitHub Actions

### 2. 核心模块设计

#### 2.1 设备连接池
```python
class DeviceConnectionPool:
    def __init__(self, max_connections: int = 5):
        self.max_connections = max_connections
        self.active_connections: Dict[str, webdriver.Remote] = {}
    
    async def execute_task(self, device_udid: str, workflow: WorkflowConfig):
        """在指定设备上执行任务"""
        driver = await self.get_driver(device_udid)
        return await asyncio.create_task(
            self._execute_workflow(driver, workflow)
        )
```

#### 2.2 工作计划系统
```python
class SmartScheduler:
    async def get_due_test_plans(self) -> List[DeviceTestPlan]:
        """获取到期的测试计划"""
        current_time = datetime.now()
        active_plans = []
        
        for device_id, plan in self.active_plans.items():
            if plan.enabled and self.is_within_schedule(plan.schedule, current_time):
                active_plans.append(plan)
        
        return active_plans
```

#### 2.3 APK管理系统
```python
class APKManager:
    async def scan_and_analyze_apk(self, apk_path: str) -> APKAnalysis:
        """扫描和分析APK文件"""
        analysis = APKAnalysis()
        
        # 提取APK基本信息
        analysis.package_info = await self.extract_package_info(apk_path)
        
        # 分析UI结构
        analysis.ui_structure = await self.analyze_ui_hierarchy(apk_path)
        
        # 生成元素定位策略
        analysis.locator_strategies = await self.generate_locator_strategies(analysis.ui_structure)
        
        return analysis
    
    async def manage_apk_lifecycle(self, device_udid: str, apk_info: APKInfo):
        """管理APK生命周期：安装、更新、卸载"""
        if apk_info.action == "install":
            return await self.install_apk(device_udid, apk_info.path)
        elif apk_info.action == "update":
            return await self.update_apk(device_udid, apk_info.path)
        elif apk_info.action == "uninstall":
            return await self.uninstall_apk(device_udid, apk_info.package_name)
```

#### 2.4 事件驱动执行
```python
class TestDataEventListener:
    async def handle_new_test_data(self, test_data: dict):
        """处理新测试数据"""
        # 查找匹配的测试计划
        matching_plans = self.condition_engine.find_matching_plans(test_data)
        
        for plan in matching_plans:
            if await self.can_execute_now(plan):
                await self.trigger_test_execution(plan, test_data)
```

### 3. 工作脚本定义规范

```yaml
name: "APK_A标准测试流程"
description: "包含登录的完整业务流程"

metadata:
  app_package: "com.target.app"
  app_activity: ".MainActivity"
  version: "1.0"

device_selection:
  strategy: "auto"
  criteria:
    min_battery: 20
    android_version: "9.0+"

steps:
  - name: "启动应用"
    action: "launch_app"
    package: "com.target.app"
    activity: ".MainActivity"
    timeout: 30
    
  - name: "点击登录按钮"
    action: "click"
    locator:
      strategies:
        - type: "id"
          value: "com.target.app:id/login_button"
        - type: "text"
          value: "登录"
    timeout: 10

schedule:
  type: "daily"
  start_time: "09:00"
  end_time: "18:00"
  interval_minutes: 120
```

---

## 四、实施指南

### 1. 环境准备

#### 1.1 依赖安装

**Java SDK安装:**
```bash
# Ubuntu/Debian
sudo apt install openjdk-11-jdk

# macOS
brew install openjdk@11

# 设置环境变量
export JAVA_HOME=/path/to/jdk
export PATH=$JAVA_HOME/bin:$PATH
```

**Android SDK安装:**
```bash
# 通过Android Studio或命令行工具安装
sdkmanager --install "platform-tools" "platforms;android-33"

# 设置环境变量
export ANDROID_HOME=$HOME/Android/Sdk
export PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH
```

**Appium安装:**
```bash
npm install -g appium
npm install -g appium-doctor

# 安装Python客户端
pip install appium-python-client
```

#### 1.2 设备配置
```bash
# 启用开发者选项和USB调试
adb devices

# 开启网络ADB
adb tcpip 5555
adb connect 192.168.1.100:5555
```

### 2. APK分析流程

#### 2.1 APK信息扫描
```python
# 使用APK扫描工具
from apk_scanner import APKScanner

scanner = APKScanner()
apps = scanner.scan_all_apps()

# 交互式选择目标APK
from interactive_apk_selector import APKSelector
selector = APKSelector()
selected_app = selector.interactive_select()
```

#### 2.2 元素定位分析

**使用Appium Inspector:**
1. 配置Desired Capabilities:
```json
{
  "platformName": "Android",
  "appPackage": "com.target.app",
  "appActivity": ".MainActivity",
  "automationName": "UiAutomator2"
}
```

2. 启动会话并分析界面元素
3. 记录元素定位策略（ID > 文本 > 无障碍标识 > XPath）

#### 2.3 工作脚本模板生成
```python
# 自动生成基础工作脚本
workscript_file = selector.generate_workscript_template(selected_app)
```

### 3. 容器化部署

#### 3.1 构建Docker镜像
```dockerfile
FROM python:3.11-slim

# 安装依赖
RUN apt-get update && apt-get install -y \
    wget unzip android-tools-adb

# 安装Android平台工具
RUN wget -q https://dl.google.com/android/repository/platform-tools-latest-linux.zip \
    && unzip platform-tools-latest-linux.zip -d /opt/

# 安装Python依赖
COPY requirements.txt .
RUN pip install -r requirements.txt

WORKDIR /app
COPY . .

CMD ["python", "main.py"]
```

#### 3.2 多平台部署配置

**Linux/WSL:**
```yaml
# docker-compose.linux.yml
services:
  autodroid-core:
    devices:
      - /dev/kvm:/dev/kvm
      - /dev/bus/usb:/dev/bus/usb
    privileged: true
```

**macOS:**
```yaml
# docker-compose.macos.yml  
services:
  autodroid-core:
    privileged: true
    extra_hosts:
      - "host.docker.internal:host-gateway"
```

**Windows:**
```yaml
# docker-compose.windows.yml
services:
  autodroid-core:
    isolation: process
    privileged: true
```

### 4. 开发实施计划

#### 阶段1：基础框架（3周）
- 容器基础镜像构建
- 设备连接管理
- Appium服务集成
- 基础API框架

**交付物:**
- 可运行的Docker镜像
- 设备连接验证工具
- 基础REST API

#### 阶段2：自动化引擎（3周）
- 工作脚本解析器
- 元素定位引擎
- 步骤执行器
- 错误处理机制

**交付物:**
- 工作流执行引擎
- 元素定位库
- 错误恢复机制

#### 阶段3：调度系统（2周）
- 计划任务调度
- 事件驱动触发
- 资源管理
- 任务队列

**交付物:**
- 工作计划系统
- 事件监听系统
- 资源监控

#### 阶段4：APK分析工具（2周）
- APK扫描工具
- 元素发现辅助
- 模板生成器
- 交互式选择

**交付物:**
- APK分析工具集
- 工作脚本模板生成器
- 用户交互界面

#### 阶段5：测试优化（2周）
- 多平台测试
- 性能优化
- 文档编写
- 用户验收测试

**交付物:**
- 完整测试报告
- 用户文档
- 部署指南

---

## 五、使用指南

### 1. 快速开始

#### 1.1 环境准备
```bash
# 1. 安装依赖
./scripts/install_dependencies.sh

# 2. 连接测试设备
adb devices

# 3. 扫描APK应用
python tools/apk_scanner.py
```

#### 1.2 容器部署
```bash
# 1. 构建镜像
docker-compose build

# 2. 启动服务
docker-compose up -d

# 3. 验证服务
curl http://localhost:8000/api/health
```

#### 1.3 创建测试计划
```bash
# 1. 选择目标APK
python tools/interactive_apk_selector.py

# 2. 使用Appium Inspector分析元素

# 3. 编辑工作脚本文件
# 4. 提交测试计划
```

### 2. 日常运维

#### 2.1 监控服务状态
```bash
# 查看容器状态
docker-compose ps

# 查看日志
docker-compose logs -f

# 监控设备连接
curl http://localhost:8000/api/devices
```

#### 2.2 管理测试计划
```bash
# 列出所有计划
curl http://localhost:8000/api/plans

# 创建新计划
curl -X POST http://localhost:8000/api/plans \
  -H "Content-Type: application/json" \
  -d '{"template_id": "apk_a", "schedule": {...}}'
```

---

## 六、附录

### 1. 故障排除

#### 1.1 常见问题
- **ADB连接失败**: 检查USB调试和网络连接
- **元素定位失败**: 使用多种定位策略组合
- **容器权限问题**: 使用privileged模式
- **设备资源不足**: 调整并发任务数量

#### 1.2 调试工具
```bash
# 检查设备连接
adb devices
adb shell dumpsys window

# 检查Appium服务
appium --log-level debug

# 查看容器日志
docker-compose logs autodroid-core
```

### 2. 性能优化建议

#### 2.1 容器配置
- 为容器分配足够内存（建议2GB+）
- 使用SSD存储提高IO性能
- 优化网络配置减少延迟

#### 2.2 测试优化
- 使用Resource ID优先定位策略
- 合理设置超时和重试参数
- 避免不必要的截图操作
- 使用数据驱动减少重复代码

### 3. 扩展开发指南

#### 3.1 添加新的定位策略
```python
class CustomLocatorStrategy:
    def locate_element(self, strategy: str, value: str):
        if strategy == "custom":
            return self.find_by_custom_method(value)
```

#### 3.2 集成新的测试数据源
```python
class CustomDataProvider:
    async def get_test_data(self, source_config: dict):
        # 实现自定义数据获取逻辑
        pass
```

---

## 总结

本文档提供了完整的跨平台安卓应用自动化容器解决方案，从需求分析到技术实现，从环境准备到日常使用，涵盖了项目实施的各个方面。开发团队可以按照分阶段实施计划，逐步构建完整的自动化测试平台。

关键成功因素：
1. **标准化**: 统一的工作脚本定义和配置管理
2. **自动化**: 最大程度减少人工干预
3. **可扩展**: 模块化设计支持功能扩展
4. **易用性**: 完善的工具链和文档支持

通过本方案，团队可以高效地进行第三方APK的自动化测试，提高测试效率和质量保证水平。


# Doubao 跨平台安卓应用自动化容器解决方案
[Linux 容器化安卓 APP 自动化测试（Python+uiautomator2+WiFi 调试 + 加固适配）](https://www.doubao.com/chat/32921572799270146)
## # 完整方案：Linux容器化安卓APP自动化测试（Python+uiautomator2+WiFi调试+加固适配）
## 一、方案整体架构
### 核心目标
开发端（Windows+WSL2）编写Python测试脚本，封装为Linux容器（Docker/Podman），他人下载容器后，通过WiFi调试连接安卓手机（兼容新旧机型），实现第三方APP（含加固）的自动化测试，开箱即用。

### 组件分工
| 角色                | 核心工具/环境                          | 职责                                  |
|---------------------|----------------------------------------|---------------------------------------|
| 开发端（Windows）| Python+weditor+WSL2                    | 编写测试脚本、调试控件、构建容器镜像  |
| 容器端（Linux）| Ubuntu/Alpine + uiautomator2 + ADB     | 运行自动化脚本、适配跨平台测试        |
| 测试设备端（安卓）| 开启WiFi调试（新旧机型适配）| 被测试的第三方APP载体                |

### 交互流程
开发端编写脚本 → 构建Linux容器镜像 → 分发镜像 → 使用者拉取镜像 → 手机开启WiFi调试 → 容器内执行脚本连接手机 → 自动化测试执行。

## 二、前置环境准备（开发端）
### 1. Windows端基础配置
#### （1）安装WSL2（Linux子系统，容器运行载体）
```powershell
# 管理员权限执行，自动安装WSL2+Ubuntu
wsl --install
# 安装完成后重启电脑，设置Ubuntu用户名/密码
```
验证：`wsl -l -v` 显示 WSL 版本为 2。

#### （2）安装容器工具（Docker/Podman二选一）
- Docker：安装 [Docker Desktop](https://www.docker.com/products/docker-desktop/)，开启“使用WSL2后端”（设置→General）。
- Podman：WSL2（Ubuntu）内执行 `sudo apt install podman -y`。

#### （3）安装开发依赖
```powershell
# 安装Python（3.7+）
# 安装uiautomator2和weditor（仅开发端用，不封装进容器）
pip install uiautomator2 weditor
```

### 2. 安卓手机前置配置（通用）
- 开启「开发者选项」：设置 → 关于手机 → 连续点击版本号7次。
- 开启「USB调试」（必开）：开发者选项内找到并开启。
- 开启「无线调试」（安卓11+）/ 允许ADB网络调试（安卓4.2.2~10）：开发者选项内配置。
- 手机与主机（运行容器的电脑）连接同一WiFi网络。

## 三、容器化封装（核心，Linux镜像）
### 1. 目录结构
```
app-test/
├── Dockerfile       # 容器构建文件
├── test_script.py   # 自动化测试脚本
└── requirements.txt # Python依赖（可选）
```

### 2. Dockerfile编写（兼容Docker/Podman）
```dockerfile
# 基础镜像：Alpine轻量化（推荐）或Ubuntu兼容性更好，二选一
# FROM alpine:3.18
FROM ubuntu:22.04

# 配置国内源（加速安装，可选）
RUN sed -i 's/archive.ubuntu.com/mirrors.aliyun.com/g' /etc/apt/sources.list && \
    apt update && apt upgrade -y

# 安装系统依赖：ADB（安卓调试工具）、Python3、pip
RUN apt install -y \
    python3 \
    python3-pip \
    android-tools-adb \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖：uiautomator2（核心）、pytest（测试用例）、lxml（XPath定位）、airtest（图像识别，适配加固APP）
RUN pip3 install uiautomator2 pytest lxml airtest --no-cache-dir -i https://pypi.tuna.tsinghua.edu.cn/simple

# 创建工作目录，复制测试脚本
WORKDIR /app
COPY test_script.py /app/

# 启动命令：默认执行测试脚本（使用者可按需修改）
CMD ["python3", "test_script.py"]
```

### 3. 构建容器镜像
```bash
# 进入WSL2，切换到app-test目录
cd /mnt/c/xxx/app-test  # Windows路径映射到WSL：C盘→/mnt/c，D盘→/mnt/d
# Docker构建
docker build -t android-auto-test:v1 .
# Podman构建（与Docker命令兼容）
podman build -t android-auto-test:v1 .
```

## 四、WiFi调试配置（分新旧安卓机型）
### 1. 新款安卓（11+）：纯无线配对（无需USB初始化）
#### （1）手机端操作
- 开发者选项 → 开启「无线调试」→ 点击进入「无线调试」。
- 选择「使用配对码配对设备」→ 记录：配对地址（如 `192.168.1.100:43887`）、配对码（如 `123456`）。
- 再记录「无线调试」的IP和端口（如 `192.168.1.100:5555`，安卓11+默认5555）。

#### （2）容器内配对并连接
```bash
# 启动容器（网络主机模式，确保能访问手机IP）
docker run -it --network host --name test-runner android-auto-test:v1 /bin/bash
# 第一步：配对设备（替换为手机的配对地址和配对码）
adb pair 192.168.1.100:43887 123456
# 第二步：连接手机（替换为手机的IP和端口）
adb connect 192.168.1.100:5555
# 验证连接：显示设备列表即为成功
adb devices
```

### 2. 老款安卓（4.2.2~10）：USB初始化WiFi调试
#### （1）首次USB初始化（仅需一次）
```bash
# 手机通过USB线连接电脑，启动容器并映射USB设备
docker run -it --network host --privileged --device=/dev/bus/usb/001/002 android-auto-test:v1 /bin/bash
# 开启WiFi调试端口（默认5555）
adb tcpip 5555
# 拔掉USB线（可保留充电，仅供电）
# 连接手机WiFi（替换为手机IP）
adb connect 192.168.1.100:5555
# 验证连接
adb devices
```
#### （2）后续使用（无需USB）
直接执行 `adb connect 192.168.1.100:5555` 即可连接。

## 五、核心测试脚本编写（兼容加固APP+WiFi调试）
### 1. 脚本功能
- 兼容新旧安卓WiFi连接方式。
- 适配加固APP的控件定位（控件ID+图像识别+XPath备用）。
- 失败捕获、自动截图、测试断言。

### 2. 完整脚本（test_script.py）
```python
import uiautomator2 as u2
import pytest
import time
from airtest.core.api import *  # 用于图像识别，适配加固APP

# ---------------------- 配置项（使用者按需修改）----------------------
PHONE_IP = "192.168.1.100"  # 手机WiFi IP
PHONE_PORT = 5555           # WiFi调试端口
APP_PACKAGE = "com.xxx.xxx" # 第三方APP包名（adb shell dumpsys window | grep mCurrentFocus 获取）
APP_ACTIVITY = ".ui.MainActivity"  # APP启动页
TEST_DATA = {
    "input_text": "自动化测试内容",
    "submit_button_text": "提交"
}
# 加固APP图像识别模板路径（需提前截图，放在容器内/app目录）
SUBMIT_BUTTON_IMG = "submit_button.png"
# -------------------------------------------------------------------

# 夹具：连接设备（兼容WiFi连接失败后自动重试）
@pytest.fixture(scope="module")
def connect_device():
    d = None
    # 尝试WiFi连接
    for _ in range(3):  # 重试3次
        try:
            d = u2.connect(f"{PHONE_IP}:{PHONE_PORT}")
            if d.device_info:
                print(f"✅ 成功连接手机：{PHONE_IP}:{PHONE_PORT}")
                break
        except Exception as e:
            print(f"❌ WiFi连接失败，重试：{e}")
            time.sleep(2)
    if not d:
        raise Exception("❌ 多次连接失败，请检查手机WiFi调试和网络")
    
    # 启动APP（冷启动，关闭现有进程）
    d.app_stop(APP_PACKAGE)
    d.app_start(APP_PACKAGE, APP_ACTIVITY)
    time.sleep(3)  # 等待APP启动（适配不同APP加载速度）
    yield d
    
    # 测试结束后清理
    d.app_stop(APP_PACKAGE)
    print("✅ 测试结束，已关闭APP")

# 核心测试用例（适配加固APP）
def test_app_operation(connect_device):
    d = connect_device
    try:
        # ---------------------- 步骤1：定位输入框（优先控件ID，加固失效则用XPath）----------------------
        try:
            # 方式1：控件ID定位（非加固APP首选）
            input_box = d(resourceId="com.xxx.xxx:id/input_edit")
            input_box.click()
            input_box.clear_text()
            input_box.set_text(TEST_DATA["input_text"])
        except:
            # 方式2：XPath定位（加固APP控件ID隐藏时备用）
            input_box = d.xpath('//android.widget.EditText[@content-desc="请输入内容"]')
            if input_box.exists:
                input_box.click()
                d.send_keys(TEST_DATA["input_text"])  # 模拟输入
            else:
                # 方式3：坐标定位（最后备选，需提前获取坐标）
                d.click(500, 300)  # 输入框坐标
                d.send_keys(TEST_DATA["input_text"])
        time.sleep(1)  # 模拟人工延迟，规避风控

        # ---------------------- 步骤2：定位提交按钮（加固APP用图像识别）----------------------
        try:
            # 方式1：文字定位（非加固APP）
            submit_btn = d(text=TEST_DATA["submit_button_text"])
            submit_btn.click(timeout=5)
        except:
            # 方式2：图像识别（加固APP首选，需提前截图模板）
            # 初始化Airtest设备（连接当前ADB设备）
            dev = connect_device_android(f"android:///{PHONE_IP}:{PHONE_PORT}")
            # 图像识别点击按钮
            if exists(Template(SUBMIT_BUTTON_IMG)):
                click(Template(SUBMIT_BUTTON_IMG))
            else:
                # 方式3：坐标定位（最后备选）
                d.click(500, 800)  # 提交按钮坐标
        time.sleep(2)

        # ---------------------- 步骤3：验证操作结果 ----------------------
        assert d(text="操作成功").exists(timeout=3), "❌ 提交失败，未找到成功提示"
        print("✅ 自动化测试执行成功！")

    except Exception as e:
        # 失败时截图留存（保存在容器/app目录）
        screenshot_name = f"fail_screenshot_{time.time()}.png"
        d.screenshot(f"/app/{screenshot_name}")
        print(f"❌ 测试失败：{str(e)}，截图已保存为 {screenshot_name}")
        raise

# 运行测试
if __name__ == "__main__":
    pytest.main(["-v", "test_script.py"])
```

### 3. 加固APP适配关键技巧
- **图像识别模板制作**：开发端用weditor截图目标按钮/输入框，保存为`submit_button.png`，放入`app-test`目录，随脚本复制到容器内。
- **Frida辅助（进阶）**：若加固APP完全屏蔽控件访问，可在容器内安装Frida（`pip3 install frida-tools`），编写Hook脚本脱壳后获取控件信息（需开发者逆向基础）。

## 六、容器运行与测试执行
### 1. 启动容器并执行测试
```bash
# 方式1：直接运行测试（Docker）
docker run --network host -v $(pwd)/screenshots:/app/screenshots android-auto-test:v1
# 方式2：进入容器交互模式（调试用）
docker run -it --network host --name test-runner android-auto-test:v1 /bin/bash
# 容器内手动执行脚本
python3 test_script.py
```
- `--network host`：容器使用主机网络，确保能访问手机WiFi IP。
- `-v $(pwd)/screenshots:/app/screenshots`：将容器内截图映射到主机，方便查看。

### 2. 使用者操作指南（开箱即用）
```bash
# 1. 拉取容器镜像
docker pull [你的镜像地址]/android-auto-test:v1
# 2. 手机开启WiFi调试（按新旧机型配置）
# 3. 修改脚本配置（手机IP、APP包名等，可通过容器环境变量传递）
docker run --network host -e PHONE_IP=192.168.1.100 android-auto-test:v1
# 4. 查看测试结果（截图保存在本地screenshots目录）
```

## 七、稳定性与兼容性优化
### 1. 规避APP风控
- 加入随机延迟：`time.sleep(random.uniform(1, 3))` 替代固定延迟，模拟人工操作。
- 避免高频操作：批量测试时加入间隔，防止被风控判定为自动化脚本。

### 2. 多设备适配
- 脚本中支持传入多个手机IP，循环连接测试：
  ```python
  PHONE_IPS = ["192.168.1.100", "192.168.1.101"]
  for ip in PHONE_IPS:
      d = u2.connect(f"{ip}:5555")
      # 执行测试逻辑
  ```

### 3. 常见故障排查
| 问题现象                | 解决方法                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| ADB连接失败             | 1. 手机与主机同WiFi；2. 重启手机无线调试；3. 执行 `adb kill-server && adb start-server` |
| 控件定位不到            | 1. 确认APP未加固（非加固APP检查控件ID）；2. 切换为图像识别/坐标定位；3. 检查APP是否启动完成 |
| 容器内无法访问手机IP    | 启动容器时加 `--network host`；关闭主机防火墙/允许容器网络访问            |
| 加固APP操作无响应       | 使用Frida Hook脱壳；或纯图像识别+坐标定位                                |

## 八、weditor使用（开发端调试控件）
开发端编写脚本时，用weditor快速获取控件属性（无需封装进容器）：
```powershell
# 启动weditor
weditor
# 浏览器打开 http://localhost:17310，输入手机IP:5555，点击Connect→Refresh
# 鼠标点击界面元素，右侧查看控件ID、XPath、坐标等信息，复制到脚本中
```

## 九、方案总结
1. **容器化核心**：Linux容器（Ubuntu/Alpine）封装依赖，跨平台兼容，使用者无需配置环境。
2. **WiFi调试**：新款安卓（11+）纯无线配对，老款安卓USB初始化后无线连接，兼顾易用性和兼容性。
3. **加固适配**：控件ID→XPath→图像识别→坐标定位，四级降级方案覆盖所有加固场景。
4. **开箱即用**：使用者仅需拉取容器、配置手机IP，即可执行测试，无需复杂配置。

该方案完美适配“Windows开发、Linux容器部署、跨机型WiFi测试、加固APP适配”的核心需求，可直接落地使用。


### 核心结论：**完全可以不关闭防火墙，仅开放指定端口即可**，无需暴露整个网络。关键是明确需要开放的端口，并针对容器网络模式配置防火墙规则。

### 一、先明确需要开放的端口
安卓WiFi调试核心依赖以下端口，只需开放这些端口即可：
| 端口类型                | 端口号/范围       | 协议 | 用途                                  | 必要性 |
|-------------------------|-------------------|------|---------------------------------------|--------|
| ADB WiFi调试核心端口    | 5555              | TCP  | 容器与手机的ADB通信（所有安卓版本）| 必开   |
| 安卓11+配对端口        | 随机端口（如43887、37099等） | TCP  | 仅安卓11+首次配对时使用，配对后无需 | 临时开 |

> 注：安卓11+的配对端口是随机生成的（手机端会显示，如 `192.168.1.100:43887`），配对完成后，后续通信仅用5555端口，因此**核心只需永久开放5555端口**，配对端口可临时开放或一次性放行。

### 二、分容器网络模式配置防火墙（推荐主机网络模式）
容器有两种主流网络模式，防火墙配置方式不同，优先推荐「主机网络模式」（简单高效）。

#### 模式1：主机网络模式（--network host，推荐）
容器直接使用主机的网络命名空间，此时只需在**主机防火墙**开放5555端口即可，无需额外配置容器端口映射。

##### 场景1：主机是Linux/WSL2（Ubuntu/Debian）（容器运行在WSL2）
Linux主机默认用`ufw`（简易防火墙）或`iptables`，以下是`ufw`配置：
```bash
# 1. 查看ufw状态（确认防火墙开启）
sudo ufw status

# 2. 永久开放5555端口（TCP协议，ADB核心端口）
sudo ufw allow 5555/tcp comment 'ADB WiFi调试端口'

# 3. （可选，安卓11+配对时临时开放）开放配对端口（如43887）
sudo ufw allow 43887/tcp comment '安卓11+配对临时端口'

# 4. 重载ufw规则（使配置生效）
sudo ufw reload

# 验证开放结果
sudo ufw status numbered
```
> 配对完成后，可删除临时配对端口规则：`sudo ufw delete 序号`（序号从`ufw status numbered`查看）。

##### 场景2：主机是Windows（容器运行在Docker Desktop/WSL2）
Windows防火墙需要创建入站规则开放5555端口：
1. 打开「控制面板 → 系统和安全 → Windows Defender 防火墙 → 高级设置」。
2. 左侧选择「入站规则」→ 右侧「新建规则」。
3. 规则类型选「端口」→ 下一步 → 选择「TCP」→ 特定本地端口输入`5555` → 下一步。
4. 选择「允许连接」→ 下一步 → 勾选「专用」「公用」（根据网络环境）→ 下一步。
5. 命名（如「ADB WiFi调试5555端口」）→ 完成。
6. （可选）安卓11+配对时，重复上述步骤开放临时配对端口（如43887）。

#### 模式2：桥接模式（容器默认模式，不推荐但可配置）
容器有独立IP（如`172.17.0.2`），需要先映射端口，再开放主机映射端口：
```bash
# 1. 启动容器时映射端口（主机5555端口映射到容器5555端口）
docker run -it --network bridge -p 5555:5555 android-auto-test:v1 /bin/bash

# 2. 主机防火墙开放5555端口（同模式1的配置，Linux/Windows分别操作）
```
> 缺点：桥接模式下需确保容器能访问手机IP（同一局域网），且端口映射可能存在冲突，不如主机网络模式直接。

### 三、验证端口开放与连通性
配置完成后，验证主机到手机5555端口的连通性，确保防火墙规则生效：
```bash
# 方式1：使用telnet测试（容器内/主机内执行）
telnet 192.168.1.100 5555  # 替换为手机IP

# 方式2：使用nc（netcat）测试（Linux/WSL2）
nc -zv 192.168.1.100 5555

# 成功提示示例：
# telnet：Connected to 192.168.1.100
# nc：Connection to 192.168.1.100 5555 port [tcp/*] succeeded!
```
若连通失败，检查：
1. 手机是否开启WiFi调试（`adb connect 手机IP:5555` 手机端是否允许）。
2. 防火墙规则是否正确（协议是否为TCP，端口是否5555）。
3. 手机与主机是否在同一局域网（无网段隔离，如路由器AP隔离是否关闭）。

### 四、额外注意事项
1. **端口协议**：ADB WiFi调试仅用TCP协议，无需开放UDP，避免不必要的端口暴露。
2. **安卓11+配对端口**：配对阶段的临时端口，可在手机端查看后临时开放，配对完成后立即关闭，提升安全性。
3. **容器网络互通**：确保容器能访问手机IP（可通过`ping 手机IP`测试容器内到手机的连通性），若ping不通，检查路由器是否开启AP隔离（需关闭）。
4. **权限问题**：Linux主机配置ufw时需用`sudo`，Windows防火墙配置需管理员权限。

### 最终配置示例（最简版）
```bash
# WSL2（Ubuntu）配置防火墙
sudo ufw allow 5555/tcp
sudo ufw reload

# 启动容器（主机网络模式）
docker run --network host android-auto-test:v1

# 容器内连接手机
adb connect 192.168.1.100:5555
```
此配置无需关闭防火墙，仅开放核心端口，兼顾安全性和功能性。